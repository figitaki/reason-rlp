// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var Char            = require("bs-platform/lib/js/char.js");
var List            = require("bs-platform/lib/js/list.js");
var $$Array         = require("bs-platform/lib/js/array.js");
var Block           = require("bs-platform/lib/js/block.js");
var Buffer          = require("bs-platform/lib/js/buffer.js");
var $$String        = require("bs-platform/lib/js/string.js");
var Js_json         = require("bs-platform/lib/js/js_json.js");
var Pervasives      = require("bs-platform/lib/js/pervasives.js");
var Caml_string     = require("bs-platform/lib/js/caml_string.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var Input_too_long = Caml_exceptions.create("Rlp-RlpReason.Input_too_long");

var Invalid_input = Caml_exceptions.create("Rlp-RlpReason.Invalid_input");

function to_binary(length) {
  if (length) {
    return to_binary(length / 256 | 0) + $$String.make(1, Char.chr(length % 256));
  } else {
    return "";
  }
}

function encode_length(length, offset) {
  if (length < 56) {
    return $$String.make(1, Char.chr(length + offset | 0));
  } else if (length < (Math.pow(258, 8) | 0)) {
    var binary_length = to_binary(length);
    return $$String.make(1, Char.chr((binary_length.length + offset | 0) + 55 | 0)) + binary_length;
  } else {
    throw [
          Input_too_long,
          "Provided input was too long."
        ];
  }
}

function parse_json(json_input) {
  var match = Js_json.classify(json_input);
  if (typeof match === "number") {
    switch (match) {
      case 0 :
      case 1 :
          throw [
                Invalid_input,
                "This library does not support boolean values."
              ];
      case 2 :
          return /* Nothing */0;

    }
  } else {
    switch (match.tag | 0) {
      case 0 :
          return /* String */Block.__(0, [match[0]]);
      case 1 :
          return /* String */Block.__(0, [Pervasives.string_of_float(match[0])]);
      case 2 :
          throw [
                Invalid_input,
                "This library doesn't support encoding objects."
              ];
      case 3 :
          return /* List */Block.__(1, [List.map(parse_json, $$Array.to_list(match[0]))]);

    }
  }
}

function create_buffer(input) {
  var buf = Buffer.create(input.length);
  Buffer.add_string(buf, input);
  return buf;
}

function is_single_char(str) {
  if (str.length === 1) {
    return +(Caml_string.get(str, 0) <= 128);
  } else {
    return /* false */0;
  }
}

function encode(data) {
  if (typeof data === "number") {
    return create_buffer("");
  } else if (data.tag) {
    var res = List.fold_left((function (acc, item) {
            return acc + Buffer.contents(encode(item));
          }), "", data[0]);
    return create_buffer(encode_length(res.length, 192) + res);
  } else {
    var s = data[0];
    if (is_single_char(s)) {
      return create_buffer(s);
    } else {
      return create_buffer(encode_length(s.length, 128) + s);
    }
  }
}

function decode(input) {
  var decoded = Buffer.create(0);
  var first_byte = Buffer.nth(input, 0);
  console.log(first_byte);
  if (first_byte <= 127) {
    Buffer.add_string(decoded, Buffer.sub(input, 0, 1));
  } else if (first_byte <= 183) {
    var length = first_byte - 127 | 0;
    if (first_byte !== 128) {
      Buffer.add_string(decoded, Buffer.sub(input, 1, length));
    }

  }
  return Buffer.to_bytes(decoded);
}

exports.Input_too_long = Input_too_long;
exports.Invalid_input  = Invalid_input;
exports.to_binary      = to_binary;
exports.encode_length  = encode_length;
exports.parse_json     = parse_json;
exports.create_buffer  = create_buffer;
exports.is_single_char = is_single_char;
exports.encode         = encode;
exports.decode         = decode;
/* No side effect */
